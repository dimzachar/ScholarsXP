generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                 String       @id @default(uuid()) @db.Uuid
  email              String       @unique
  username           String?
  role               UserRole     @default(USER)
  totalXp            Int          @default(0)
  currentWeekXp      Int          @default(0)
  streakWeeks        Int          @default(0)
  missedReviews      Int          @default(0)
  profileImageUrl    String?
  bio                String?
  joinedAt           DateTime     @default(now())
  lastActiveAt       DateTime?
  preferences        Json         @default("{}")
  // Discord authentication fields
  discordId          String?      @unique
  discordHandle      String?
  discordAvatarUrl   String?
  submissions        Submission[]
  peerReviews        PeerReview[]
  weeklyStats        WeeklyStats[]
  reviewAssignments  ReviewAssignment[]
  userAchievements   UserAchievement[]
  contentFlags       ContentFlag[]
  adminActions       AdminAction[]
  xpTransactions     XpTransaction[]
  notifications      Notification[]
  rolePromotionNotifications RolePromotionNotification[]
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt

  // Performance indexes for N+1 query optimization
  @@index([createdAt])             // User registration analytics
  @@index([lastActiveAt])          // Activity status queries
  @@index([role, createdAt])       // Role-based analytics
  @@index([lastActiveAt, createdAt]) // Analytics queries optimization
  @@index([totalXp(sort: Desc)])   // Leaderboard queries optimization
  @@index([lastActiveAt, totalXp], map: "idx_user_active_recent") // Active users partial index
}

model Submission {
  id                 String       @id @default(uuid()) @db.Uuid
  userId             String       @db.Uuid
  url                String       @unique // Prevent duplicate URLs across all users
  title              String?      // Optional title for the submission
  content            String?      // Optional content preview
  platform           String       // e.g. "Twitter", "Medium"
  taskTypes          String[]     // Array of task types for PostgreSQL
  aiXp               Int
  originalityScore   Float?
  peerXp             Int?
  finalXp            Int?
  status             SubmissionStatus @default(PROCESSING)
  reviewDeadline     DateTime?
  consensusScore     Float?
  reviewCount        Int          @default(0)
  flagCount          Int          @default(0)
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  weekNumber         Int
  peerReviews        PeerReview[]
  reviewAssignments  ReviewAssignment[]
  contentFlags       ContentFlag[]
  aiEvaluation       AiEvaluation?
  contentFingerprints ContentFingerprint[]
  xpTransactions     XpTransaction[] @relation("SubmissionXpTransactions")
  submissionProcessing SubmissionProcessing?
  user               User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Performance indexes for N+1 query optimization
  @@index([userId, createdAt])     // User activity queries
  @@index([status, createdAt])     // Admin filtering and analytics
  @@index([createdAt])             // Time-based analytics (time series)
  @@index([platform, createdAt])   // Platform analytics
  @@index([status, createdAt, platform]) // Enhanced admin analytics
}

model PeerReview {
  id             String     @id @default(uuid()) @db.Uuid
  reviewerId     String     @db.Uuid
  submissionId   String     @db.Uuid
  xpScore        Int
  comments       String?
  timeSpent      Int?       // in minutes
  qualityRating  Int?       @db.SmallInt // 1-5 rating
  isLate         Boolean    @default(false)
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  reviewer       User       @relation(fields: [reviewerId], references: [id], onDelete: Cascade)
  submission     Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  // Performance indexes for N+1 query optimization
  @@index([submissionId])          // Review lookups
  @@index([reviewerId, createdAt]) // Reviewer activity queries
  @@index([createdAt])             // Time-based analytics
  @@index([reviewerId, createdAt, xpScore]) // Enhanced reviewer analytics
}

model WeeklyStats {
  id             String     @id @default(uuid()) @db.Uuid
  userId         String     @db.Uuid
  weekNumber     Int
  xpTotal        Int
  reviewsDone    Int
  reviewsMissed  Int
  earnedStreak   Boolean    @default(false)
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  user           User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, weekNumber])
  @@index([weekNumber, userId, xpTotal]) // Weekly analytics optimization
}

model ReviewAssignment {
  id             String                @id @default(uuid()) @db.Uuid
  submissionId   String                @db.Uuid
  reviewerId     String                @db.Uuid
  assignedAt     DateTime              @default(now())
  deadline       DateTime
  status         ReviewAssignmentStatus @default(PENDING)
  completedAt    DateTime?
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt

  submission     Submission            @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  reviewer       User                  @relation(fields: [reviewerId], references: [id], onDelete: Cascade)

  @@unique([submissionId, reviewerId])
}

model Achievement {
  id             String              @id @default(uuid()) @db.Uuid
  name           String              @unique @db.VarChar(100)
  description    String
  category       AchievementCategory
  iconUrl        String?
  xpReward       Int                 @default(0)
  criteria       Json                // Flexible criteria definition
  isActive       Boolean             @default(true)
  createdAt      DateTime            @default(now())

  userAchievements UserAchievement[]
}

model UserAchievement {
  id             String      @id @default(uuid()) @db.Uuid
  userId         String      @db.Uuid
  achievementId  String      @db.Uuid
  earnedAt       DateTime    @default(now())

  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement    Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([earnedAt, userId]) // Achievement analytics optimization
}

model ContentFlag {
  id             String      @id @default(uuid()) @db.Uuid
  submissionId   String      @db.Uuid
  flaggedBy      String      @db.Uuid
  reason         FlagReason
  description    String?
  status         FlagStatus  @default(PENDING)
  resolvedBy     String?     @db.Uuid
  resolvedAt     DateTime?
  createdAt      DateTime    @default(now())

  submission     Submission  @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  flagger        User        @relation(fields: [flaggedBy], references: [id], onDelete: Cascade)

  @@index([status, createdAt]) // Content moderation optimization
}

model AdminAction {
  id             String          @id @default(uuid()) @db.Uuid
  adminId        String          @db.Uuid
  action         AdminActionType
  targetType     String          @db.VarChar(50) // 'user', 'submission', 'review', etc.
  targetId       String          @db.Uuid
  details        Json?
  createdAt      DateTime        @default(now())

  admin          User            @relation(fields: [adminId], references: [id], onDelete: Cascade)
}

model XpTransaction {
  id             String            @id @default(uuid()) @db.Uuid
  userId         String            @db.Uuid
  amount         Int               // Can be negative for penalties
  type           XpTransactionType
  sourceId       String?           @db.Uuid // Reference to submission, review, etc.
  description    String
  weekNumber     Int
  createdAt      DateTime          @default(now())
  sourceType     String?           // Type of source (e.g., 'LEGACY_SUBMISSION')
  adminId        String?           @db.Uuid // Admin who made the change

  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  submission     Submission?       @relation("SubmissionXpTransactions", fields: [sourceId], references: [id], onDelete: Cascade)

  // Performance indexes for N+1 query optimization
  @@index([userId, createdAt])     // User XP history queries
  @@index([type, createdAt])       // Transaction type analytics
  @@index([createdAt])             // Time-based analytics
  @@index([userId, type, createdAt]) // Enhanced XP analytics
}

enum SubmissionStatus {
  PROCESSING           // New: Initial state during background processing
  PENDING              // Existing: Validation passed, ready for AI
  AI_REVIEWED          // Existing: AI evaluation complete
  UNDER_PEER_REVIEW    // Existing: Peer review in progress
  FINALIZED            // Existing: Final XP awarded
  FLAGGED              // Existing: Manual review needed
  REJECTED             // Existing: Failed validation
}

enum UserRole {
  USER
  REVIEWER
  ADMIN

  @@map("user_role")
}

enum ReviewAssignmentStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  MISSED
  REASSIGNED
}

enum AchievementCategory {
  SUBMISSION
  REVIEW
  STREAK
  MILESTONE
  SPECIAL
}

enum FlagReason {
  INAPPROPRIATE
  SPAM
  PLAGIARISM
  OFF_TOPIC
  QUALITY
  OTHER
}

enum FlagStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

enum AdminActionType {
  XP_OVERRIDE
  USER_ROLE_CHANGE
  CONTENT_FLAG
  REVIEW_REASSIGN
  SYSTEM_CONFIG
}

enum XpTransactionType {
  SUBMISSION_REWARD
  REVIEW_REWARD
  STREAK_BONUS
  PENALTY
  ADMIN_ADJUSTMENT
  ACHIEVEMENT_BONUS
}

enum NotificationType {
  XP_AWARDED
  REVIEW_ASSIGNED
  REVIEW_COMPLETED
  SUBMISSION_PROCESSED
  SUBMISSION_PROCESSING
  SUBMISSION_APPROVED
  SUBMISSION_REJECTED
  WEEKLY_SUMMARY
  STREAK_ACHIEVED
  PENALTY_APPLIED
  ADMIN_MESSAGE
}

model RateLimit {
  id           String   @id @default(uuid()) @db.Uuid
  identifier   String   @db.VarChar(255)
  endpointType String   @db.VarChar(50)
  requestCount Int      @default(1)
  windowStart  DateTime
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  @@unique([identifier, endpointType, windowStart])
  @@index([identifier, endpointType, expiresAt], name: "idx_rate_limits_lookup")
  @@index([expiresAt], name: "idx_rate_limits_cleanup")
}

model Notification {
  id        String           @id @default(uuid()) @db.Uuid
  userId    String           @db.Uuid
  type      NotificationType
  title     String           @db.VarChar(255)
  message   String           @db.Text
  data      Json?            // Flexible data storage for notification context
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relationships
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance
  @@index([userId, createdAt], name: "idx_notifications_user_created")
  @@index([userId, read], name: "idx_notifications_user_read")
  @@index([createdAt], name: "idx_notifications_cleanup")
  @@map("notifications")
}

// AI Evaluation System Tables

model AiEvaluation {
  id                    String    @id @default(uuid()) @db.Uuid
  submissionId          String    @unique @db.Uuid
  status                String    @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  taskTypes             String[]
  baseXp                Int?
  originalityScore      Float?
  qualityScore          Float?
  confidence            Float?
  reasoning             String?
  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  errorMessage          String?
  retryCount            Int       @default(0)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relationships
  submission            Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([status])
  @@index([createdAt])
  @@index([retryCount])
  @@map("AiEvaluation")
}

model LegacySubmission {
  id                String              @id @default(uuid()) @db.Uuid
  url               String              @unique
  discordHandle     String?
  submittedAt       DateTime?
  role              String?
  notes             String?
  importedAt        DateTime            @default(now())
  processed         Boolean             @default(false)
  aiXp              Int?                @default(0)
  peerXp            Int?
  finalXp           Int?
  contentFingerprints ContentFingerprint[]

  // Indexes
  @@index([discordHandle])
  @@index([processed])
  @@index([submittedAt])
  @@map("LegacySubmission")
}

model ContentFingerprint {
  id                  String            @id @default(uuid()) @db.Uuid
  submissionId        String?           @db.Uuid
  legacySubmissionId  String?           @db.Uuid
  hash                String
  normalizedContent   String?
  keyPhrases          String[]
  contentLength       Int
  wordCount           Int
  url                 String
  platform            String
  createdAt           DateTime          @default(now())

  // Relationships
  submission          Submission?       @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  legacySubmission    LegacySubmission? @relation(fields: [legacySubmissionId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([hash])
  @@index([url])
  @@index([submissionId])
  @@index([legacySubmissionId])
  @@map("ContentFingerprint")
}

model RolePromotionNotification {
  id               String   @id @default(uuid()) @db.Uuid
  userId           String   @db.Uuid
  oldRole          String
  newRole          String
  xpAtPromotion    Int
  notificationSent Boolean  @default(false)
  discordHandle    String?
  createdAt        DateTime @default(now())

  // Relationships
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([userId])
  @@index([notificationSent])
  @@index([createdAt])
  @@map("RolePromotionNotification")
}

model SystemLog {
  id        String   @id @default(uuid()) @db.Uuid
  level     String   // INFO, WARN, ERROR
  message   String
  metadata  Json?
  createdAt DateTime @default(now())

  // Indexes
  @@index([level])
  @@index([createdAt])
  @@map("SystemLog")
}

model SubmissionProcessing {
  id                    String    @id @default(uuid()) @db.Uuid
  submissionId          String    @unique @db.Uuid
  status                String    @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  priority              String    @default("NORMAL") // HIGH, NORMAL, LOW
  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  errorMessage          String?
  retryCount            Int       @default(0)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relationships
  submission            Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  // Indexes for efficient queue processing
  @@index([status, priority, createdAt])
  @@index([status, retryCount])
  @@map("SubmissionProcessing")
}

model ApiRateLimit {
  id           Int      @id @default(autoincrement())
  platform     String   // e.g., "twitter", "reddit"
  endpoint     String   // e.g., "tweet_lookup", "post_fetch"
  requestsMade Int      @default(0)
  windowStart  DateTime @default(now())
  createdAt    DateTime @default(now())

  // Unique constraint to prevent duplicate records for same platform/endpoint/window
  @@unique([platform, endpoint, windowStart])
  @@index([platform, endpoint, windowStart])
  @@map("api_rate_limits")
}

// Automation logging for cron jobs and manual admin operations
model AutomationLog {
  id           String    @id @default(uuid()) @db.Uuid
  jobName      String    // e.g., "weekly-operations-cron", "xp-aggregation-cron"
  jobType      String    // e.g., "weekly_operations", "xp_aggregation", "manual"
  triggeredBy  String    // e.g., "cron", admin user ID
  startedAt    DateTime  @default(now())
  completedAt  DateTime?
  status       String    @default("RUNNING") // "RUNNING", "SUCCESS", "FAILED"
  result       String?   // JSON string with operation results
  errorMessage String?
  duration     Int?      // Duration in milliseconds
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Indexes for efficient querying
  @@index([jobType, startedAt(sort: Desc)])
  @@index([status, startedAt(sort: Desc)])
  @@index([jobName, startedAt(sort: Desc)])
  @@index([triggeredBy, startedAt(sort: Desc)])
  @@map("AutomationLog")
}